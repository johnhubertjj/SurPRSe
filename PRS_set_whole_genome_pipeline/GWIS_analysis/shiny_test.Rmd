---
title: "COGS_pathway_DSM"
runtime: shiny
output: html_document
---

# SUMMARY for 22/02/17

* Age and gender have been added as covariates to COGS
* Regulatory regions for both whole genome and pathway PRS have been updated and are fully functional in the pipeline
* A new DSM group of AllminusNarrow Schizophrenia has been defined as a measure to check accuracy of results (still in progress)

# RESULTS Summary

* With extended gene regions, abnormal grooming behaviour consistently predicts cognition across all p-value thresholds and even captures more variation than a whole genome PRS
* FMRP targets geneset drops in significance when extended gene regions added
* Cav 2 channels increase in  significance

* BETA Directions: 
  * whole genome (both genic and all) = negative
  * Cav2 = negative
  * abnormal grooming behaviour = negative
  * FMRP = positive but insignificant with extended regions included

* If narrow SCZ DSM measure is removed, beta of a whole genome PRS switches to positive association but low sample size and insignificant

# Discussion points

* Run data-driven pathway analysis? (link up with Andrews annotations)
* Use a gene-PRS to decipher which segments are contributing to the signal in gene-set PRS?
* Software engineers
* Still worth defining new sets based on LoF and FMRP?
* More narrow examination at this analysis?
* Secondary proposal for BD de-duplicated from SCZ


## INFORMATION

#### Polygenic risk score

**QC**

* SE > 5
* MAF < 0.1
* HWE 1e-04, mid-p, include nonctrl in COGS.
* genotype missingness thresh = 0.1
* Clumping
  * p1 = 1
  * p2 = 1
  * r2 = 0.1
  * window = 500kb
  
* Gene-set PRS have been limited to genic SNPs, then clumped within gene-set
* Whole genome PRS has been limited to genic SNPs
  
#### Sample sizes

* COGS = 1024
* CLOZUK_PGC2_NO_COGS \~ 104,000

#### Gene sets

* 5HT_2C
* abnormal behaviour
* abnormal grooming behaviour (such a weird set, you'll see why in a second)
* abnormal LTP
* abnormal nervous system electrophysiology
* Calcium ion import (GO)
* Cav2 channels
* FMRP targets
* LOF intolerance
* Membrane Depolarisation during action potential (GO)
* Synaptic transmission (GO)



* All taken from James + Antonio's paper apart from GO terms which were defined in Amigo GO
  * GO terms were part of a conditional analysis at the top of Antonio's/James' paper in a data-driven pathway analysis so I've included them here
#### Phenotypes

**DSM**

1. Schizophrenia
2. Schizoaffective depressed
3. Schizoaffective bipolar
4. Other psychotic disorder
5. Bipolar 1
6. Bipolar 2
7. Depression
8. Other (e.g. OCD)
9. Missing

* DSM 1-4 is classified as "broad" Schizophrenia
* DSM 1-2 is classified as "narrow" SCZ

**ICD**

+ Same format as DSM?
  
**Composite_Zimpute**

+ Composite measure from MATRICS. Imputed for missing data
  + MATRICS is the "IQ test for schizophrenia" and is mean zero centered
  + Composite of many metrics of various forms of cognition into one score
    
**FINAL_CLOZ_ever**

+ Has the individual ever received clozapine treatment?
  + Cleaned from interview and self-reported
  + If self-reported stated 'no' for in the interview but 'yes' to clozapine, the reported answer was 'yes'
    
1 Yes  
0 No  
9 Missing  

**FINAL_TRS**

* Does the individual have treatment-resistant schizophrenia?
  * Cleaned from OPCRIT 89 (response to neuroleptics) and FINAL_Cloz_Ever
  * Classed as TRS if 'yes' to either above 
    
1 TRS  
0 non-TRS  
9 Missing  
  
* Only a few missing from TRS compared to clozapine so both TRS measures will correlate highly if used

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Insert Libraries

```{r, message=FALSE, include=F, results = 'hide'}
# required packages -- will only install if they are not already installed
list.of.packages <- c("plyr", "stringr", "dplyr", "tidyr", "reshape2", "ggplot2", "scales", "data.table", "plotly", "devtools", "gridExtra", "cowplot", "repr", "knitr", "kableExtra", "IRdisplay","DT")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


#library(ggplot2) 
    
# loads the required packages
lapply(list.of.packages, require, character.only = TRUE)

library(data.table)
library(plyr)
library(dplyr)
library(rms)
```


## Files I need

Files that are required to be read into this analysis:

* COGS duplicates with PGC
* COGS covariates
* Pathway results with COGS and CLOZUK_PGC2_noCOGS summarised
* Phenotype files with DSM information and Cognition and treatment resistance
* COGS gene boundaries (normal) gene set polygenic risk scores
* COGS regulatory regions (+ 10kb, -35kb from gene boundary; extended) gene set polygenic risk scores
* COGS whole genome genic (gene boundaries = normal; regulatory regions = extended) polygenic risk scores
* COGS whole genome polygenic risk scores

#### Read in whole genome normal and extended genic files before separating
```{r}
significance_threshold <- c(5e-08,1e-06,1e-04,0.01,0.05,0.1,0.2,0.5,1)

my_files <- paste0("~/Documents/COGS_pathways_results/whole_genome/PRS_scoring/PRS_scoring/CLOZUK_PGC2_noCOGS_COGS_normal_gene_regions_Clumped_whole_genome_final_significance_threshold_at_",significance_threshold, ".profile")


my_data <- lapply(my_files, fread, header=TRUE) 
names(my_data) <- str_replace(my_files, pattern = ".profile", replacement = "")

# iterate through significance thresholds 
for (i in 1:length(significance_threshold)) {
  my_data[[i]] <- my_data[[i]][,c(1,2,6)]
  colnames(my_data[[i]]) <- c("FID", "IID", paste("SCORE_whole_genome_", significance_threshold[i], sep=""))
}

all_prs_normal <- join_all(my_data, by=c("FID", "IID"), type='left')

cols <- names(all_prs_normal)[3:ncol(all_prs_normal)]
setnames(all_prs_normal, old = c(3:ncol(all_prs_normal)), new = paste("normal.genic.genome", cols, sep = "_"))

my_files <- paste0("~/Documents/COGS_pathways_results/whole_genome/PRS_scoring/PRS_scoring/CLOZUK_PGC2_noCOGS_COGS_extended_gene_regions_Clumped_whole_genome_final_significance_threshold_at_",significance_threshold, ".profile")


my_data <- lapply(my_files, fread, header=TRUE) 
names(my_data) <- str_replace(my_files, pattern = ".profile", replacement = "")

# iterate through significance thresholds 
for (i in 1:length(significance_threshold)) {
  my_data[[i]] <- my_data[[i]][,c(1,2,6)]
  colnames(my_data[[i]]) <- c("FID", "IID", paste("SCORE_whole_genome_", significance_threshold[i], sep=""))
}

all_prs_extended <- join_all(my_data, by=c("FID", "IID"), type='left')

cols <- names(all_prs_extended)[3:ncol(all_prs_extended)]
setnames(all_prs_extended, old = c(3:ncol(all_prs_extended)), new = paste("extended.genic.genome", cols, sep = "_"))

```

#### Read in whole genome; entire genome
```{r}
my_files <- paste0("~/Documents/COGS_pathways_results/whole_genome/PRS_scoring/CLOZUKPGC2_NO_COGS_COGS_whole_genome_significance_threshold_at_",significance_threshold, ".profile")

my_data <- lapply(my_files, fread, header=TRUE) 
names(my_data) <- str_replace(my_files, pattern = ".profile", replacement = "")

# iterate through significance thresholds 
for (i in 1:length(significance_threshold)) {
  my_data[[i]] <- my_data[[i]][,c(1,2,6)]
  colnames(my_data[[i]]) <- c("FID", "IID", paste("SCORE_whole_genome_", significance_threshold[i], sep=""))
}

all_prs_whole_genome <- join_all(my_data, by=c("FID", "IID"), type='left')
cols <- names(all_prs_whole_genome)[3:ncol(all_prs_whole_genome)]
setnames(all_prs_whole_genome, old = c(3:ncol(all_prs_whole_genome)), new = paste("All.genome", cols, sep = "_"))

```
### Add column patterns to distinguish between gene boundaries and regulatory regions

```{r}
COGS_Pathway_results_normal = fread("~/Documents/COGS_pathways_results/FINAL_PATHWAY_RESULTS_PRS_PROFILESCLOZUK_PGC2_noCOGS_COGS_Selected_Pocklington_plus_GO_pathways_SCHIZ_normal.txt")
cols <- names(COGS_Pathway_results_normal)[3:ncol(COGS_Pathway_results_normal)]
setnames(COGS_Pathway_results_normal, old = c(3:ncol(COGS_Pathway_results_normal)), new = paste("normal_geneset", cols, sep = "_"))

COGS_Pathway_results_extended = fread("~/Documents/COGS_pathways_results/FINAL_PATHWAY_RESULTS_PRS_PROFILESCLOZUK_PGC2_noCOGS_COGS_Selected_Pocklington_plus_GO_pathways_SCHIZ_extended.txt")
cols <- names(COGS_Pathway_results_extended)[3:ncol(COGS_Pathway_results_extended)]
setnames(COGS_Pathway_results_extended, old = c(3:ncol(COGS_Pathway_results_extended)), new = paste("extended_geneset", cols, sep = "_"))

```


#### Read in all input files

```{r}

COGS_Phenotypes = fread("~/Documents/COGS_pathways_results/Phenotypes.txt")
COGS_ID_S = fread("~/Documents/COGS_pathways_results/COGS_IDs_V2.txt")
setnames(COGS_Phenotypes, old = "ID", new = "Study_ID")
COGS_Phenotypes <- merge(COGS_Phenotypes,COGS_ID_S, by = "Study_ID")

COGS_list <- list(
COGS_covaraties = fread("~/Documents/COGS_pathways_results/COGSv2016.noREL.eigenvec"),
COGS_duplicates = fread("~/Documents/COGS_pathways_results/COGSv2016.PGCrelatives[2] copy.txt", header = F),
#COGS_Pathway_results = fread("~/Documents/COGS_pathways_results/FINAL_PATHWAY_RESULTS_PRS_PROFILESCLOZUKPGC2_NO_COGS_COGS_Selected_Pocklington_plus_GO_pathways_SCHIZ.txt"),
COGS_Pathway_results_normal = COGS_Pathway_results_normal,
COGS_Pathway_results_extended = COGS_Pathway_results_extended,
COGS_age_gender = fread("~/Documents/COGS_pathways_results/COGS_AGE_SEX_Feb_18.txt"),
COGS_whole_genome_genic_normal = all_prs_normal,
COGS_whole_genome_genic_extended = all_prs_extended,
COGS_whole_genome = all_prs_whole_genome,
#COGS_Pathway_test_randomisation <- fread("~/Documents/COGS_pathways_results/FINAL_PATHWAY_RESULTS_PRS_PROFILESCLOZUKPGC2_NO_COGS_COGS_abnormal_behaviorrandomised_gene_sets.txt")
COGS_Phenotypes = COGS_Phenotypes
)


```

## Restrict ID's to ones without duplicates/covariates/phenotype information

```{r}
setnames(COGS_list$COGS_duplicates, c("FID", "IID"))
COGS_total <- join_all(dfs=COGS_list,by = "IID",type = "left")
setkey(COGS_total,IID)
COGS_total <- COGS_total[!COGS_list$COGS_duplicates$IID]
COGS_total_copy <- copy(COGS_total)
```

## Scale all Polygenic risk scores
* Used the first five covariates in COGS, limited down to individuals for which we have covariates for...
* Standardised the polygenic risk score afterwards

```{r}
# PRS_tables <- COGS_total[, .SD, .SDcols = (names(COGS_total) %like% "SCORE" | names(COGS_total) %like% "PC")]

PRS_scores <- grep(x = names(COGS_total), pattern = "SCORE")
PRS_names <- colnames(COGS_total[, .SD, .SDcols = PRS_scores])
PC_s <- grep(x = names(COGS_total), pattern = "PC\\d+")

  for (l in PRS_scores){
    model0 <- glm(COGS_total[[l]] ~ PC1 + PC2 + PC3 + PC4 + PC5, family = gaussian, data = COGS_total)
    m1<-mean(residuals(model0))
    sd1<-sd(residuals(model0))
    NORMSCORE <- (residuals(model0)-m1)/sd1
    COGS_total[,(l) := NORMSCORE]
  }

```

## Limit to DSM (narrow and broad) and run multiple linear regressions on cognition

* SCZ all cognition = 772 individuals after QC
* SCZ all TRS =  812 individuals after QC

* SCZ narrow = 678 individuals after QC
* SCZ broad = 827 individuals after QC

* SCZ all minus narrow cognition = 182 after removing missing values
* SCZ narrow cognition = 586 after removing missing values
* SCZ broad cognition = 725 after removing missing values

* SCZ all minus narrow TRS = 172 after removing missing values
* SCZ narrow TRS = 638 after removing missing values
* SCZ broad TRS = 773 after removing missing values

## Limiting to age and gender phenotypes

* Age at interview
* Gender
  * 1 = male
  * 0 = female

* No NA values in covariates are seen after QC above (some are seen in full dataset but are removed by coincidence)


```{r, message=FALSE}
# create separted DF for narrow and broad SCZ

rows_to_keep_SCZ_narrow <- COGS_total[DSM_diagnosis_new == 1 | DSM_diagnosis_new == 2 ]
rows_to_keep_SCZ_broad <- COGS_total[DSM_diagnosis_new == 1 | DSM_diagnosis_new == 2 | DSM_diagnosis_new == 3 | DSM_diagnosis_new == 4]
rows_to_keep_all_minus_narrow <- COGS_total[DSM_diagnosis_new != 1 & DSM_diagnosis_new != 2]

COGS_cognition <- COGS_total[Composite_Zimpute != 999]
COGS_treatment_resistance <- COGS_total[FINAL_TRS != 9]

rows_to_keep_SCZ_narrow_cognition <- rows_to_keep_SCZ_narrow[Composite_Zimpute != 999]
rows_to_keep_SCZ_broad_cognition <- rows_to_keep_SCZ_broad[Composite_Zimpute != 999]
rows_to_keep_SCZ_narrow_TRS <- rows_to_keep_SCZ_narrow[FINAL_TRS != 9]
rows_to_keep_SCZ_broad_TRS <- rows_to_keep_SCZ_broad[FINAL_TRS != 9]

rows_to_keep_all_minus_narrow_cognition <- rows_to_keep_all_minus_narrow[Composite_Zimpute != 999]
rows_to_keep_all_minus_narrow_TRS <- rows_to_keep_all_minus_narrow[FINAL_TRS != 9]


list_of_tests_cognition <- list(
  rows_to_keep_SCZ_narrow_cognition = as.data.frame(rows_to_keep_SCZ_narrow_cognition[, test:= Composite_Zimpute]),
  rows_to_keep_SCZ_broad_cognition = as.data.frame(rows_to_keep_SCZ_broad_cognition[, test := Composite_Zimpute]),
  rows_to_keep_SCZ_all_minus_narrow_cognition = as.data.frame(rows_to_keep_all_minus_narrow_cognition[, test := Composite_Zimpute]),
  COGS_cognition = as.data.frame(COGS_cognition[,test:= Composite_Zimpute])
  )  

list_of_tests_TRS <- list(
  rows_to_keep_SCZ_narrow_TRS = as.data.frame(rows_to_keep_SCZ_narrow_TRS[,test := FINAL_TRS]),
  rows_to_keep_SCZ_broad_TRS = as.data.frame(rows_to_keep_SCZ_broad_TRS[,test:= FINAL_TRS]),
  rows_to_keep_SCZ_all_minus_narrow_TRS = as.data.frame(rows_to_keep_all_minus_narrow_TRS[,test := FINAL_TRS]),
  COGS_treatment_resistance = as.data.frame(COGS_treatment_resistance[,test:= FINAL_TRS])
)

# create a score list
score_list <- PRS_names
names_of_analyses <- names(list_of_tests_cognition)


# this example if for a linear regression (the phenotype of interest is a quantiative trait)
# is using a discrete phenotype, a logistic regression needs to be run, and the code altered from 'lm' to 'glm' including the argument of 'family = binomial'
# alterations for the calculation of R2 will also need to be made using the command highlighted above
for (l in names_of_analyses){
obj <- data.frame(test=0, score=0, estimate=0, SE=0, tvalue=0, p=0, r.squared=0, lower = 0, upper = 0)
for (i in score_list) {
    fit <- lm(test ~ list_of_tests_cognition[[l]][,i] + male_sex + Age_at_Interview,  data=list_of_tests_cognition[[l]])
    fit2 <- lm (test ~ male_sex + Age_at_Interview, data = list_of_tests_cognition[[l]])
    tmp <- coef(summary(fit))
    tmp2 <- summary(fit)
    hold <- summary(fit2)
    true_r2 <- tmp2$r.squared - hold$r.squared
    CI <- confint(fit, level=0.95)
    CI <- CI[2,]
    tmp3 <- c(l,i,tmp[2,], true_r2, CI)
    obj <- rbind(obj, tmp3)
}
  results <- obj[which(obj$score %in% score_list),]
  assign(paste0("results_",l), results)
}

names_of_analyses <- names(list_of_tests_TRS)

for (l in names_of_analyses){
obj <- data.frame(test=0, score=0, estimate=0, SE=0, zvalue=0, p=0, r.squared.Nagel=0, lower = 0, upper = 0)
for (i in score_list) {
    fit <- lrm(test ~ list_of_tests_TRS[[l]][,i] + male_sex + Age_at_Interview, data = list_of_tests_TRS[[l]],se.fit = T)
    fit2 <- glm(test ~ list_of_tests_TRS[[l]][,i] + male_sex + Age_at_Interview, data = list_of_tests_TRS[[l]], family = "binomial")
    tmp <- coef(summary(fit2))
    
    SE <- sqrt(diag(vcov(fit)))
    SE <- SE[2]
    Coef <- fit$coefficients[2]
    
    CI <- confint(fit2, level=0.95)
    CI <- CI[2,]
    # upper CI for beta
    CI_upper <- exp((Coef)+(1.96*SE))
    # lower CI for beta
    CI_lower <- exp((Coef)-(1.96*SE))
    tmp2 <- fit$stats
    Nagel_r2 <- tmp2[c("R2")]
    
    tmp3 <- c(l,i,tmp[2,], Nagel_r2, CI)
    obj <- rbind(obj, tmp3)
}
  results <- obj[which(obj$score %in% score_list),]
  assign(paste0("results_",l), results)
}
```
#### NOTES

* For logistic regression, confit in R might produce different CI's than manual CI's in R see here: [http://people.upei.ca/hstryhn/stryhn208.pdf]
  * and here: [https://stats.stackexchange.com/questions/5304/why-is-there-a-difference-between-manually-calculating-a-logistic-regression-95]


#### TABLES

* Need to do these sets of analysis and plot each one for broad, narrow, all and allminusnarrow
  * compare pathways against a whole genome genic with normal regions
  * compare pathways against a whole genome genic with extended regions
  * compare normal pathways against a whole genome without regions
  * compare extended pathways against a whole genome without regions
  
* Also make secondary proposal for de-duplication against the PGC for Bipolar cases and controls
* Will convert all of this to a Shiny app
*   
```{r echo=F,results='asis', message=F, warning=F}

all_cogs_PRS_results <- list(
  Cognition_all_samples = results_COGS_cognition,
  Cognition_broad = results_rows_to_keep_SCZ_broad_cognition,
  Cognition_narrow = results_rows_to_keep_SCZ_narrow_cognition,
  Cognition_minus_narrow = results_rows_to_keep_SCZ_all_minus_narrow_cognition
  )

all_TRS_PRS_results <- list (
  TRS_all_samples <- results_COGS_treatment_resistance,
  TRS_broad <- results_rows_to_keep_SCZ_broad_TRS,
  TRS_narrow <- results_rows_to_keep_SCZ_narrow_TRS,
  TRS_minus_narrow <- results_rows_to_keep_SCZ_all_minus_narrow_TRS
)

library(knitr)

samples <- c("Everything", "broad", "narrow", "All_minus_narrow")

for (i in 1:length(samples)){
  all_cogs_PRS_results[[i]] <- cbind(all_cogs_PRS_results[[i]], samples[i])
} 

Full_data <- ldply(all_cogs_PRS_results, data.frame)
Full_data <- as.data.table(Full_data)

#for (t in 1:4){
  
Final_analysis <- list(
current_table_extended <- Full_data[grepl("^extended",Full_data$score)],
current_table_normal <- Full_data[grepl("^normal",Full_data$score)],
current_table_extended_All.genome <- Full_data[grepl("^extended",Full_data$score) | grepl("All.genome", Full_data$score)],
current_table_normal_All.genome <- Full_data[grepl("^normal", Full_data$score) | grepl("All.genome", Full_data$score)]
)
```

```{r, message=FALSE, include=F, results = 'hide'}
# required packages -- will only install if they are not already installed
list.of.packages <- c("plyr", "stringr", "dplyr", "tidyr", "reshape2", "ggplot2", "scales", "data.table", "plotly", "devtools", "gridExtra", "cowplot", "repr", "knitr", "kableExtra", "IRdisplay","DT")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)


#library(ggplot2) 
    
# loads the required packages
lapply(list.of.packages, require, character.only = TRUE)

library(data.table)
library(plyr)
library(dplyr)
library(rms)
```

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE}
Full_data <- fread("test_run")

Full_data[, Genesets := gsub(pattern = ".*_SCORE_(.*)_.*", replacement = "\\1", x = Full_data$score,perl = T)]
Full_data[, Gene_regions := gsub(pattern = "^(.*)_geneset_SCORE_.*", replacement = "\\1", x = Full_data$score,perl = T)]
Full_data[, Significance_thresholds := gsub(pattern = ".*_(.*$)", replacement = "\\1", x = Full_data$score,perl = T)]

Gene.sets.input <- unique(Full_data$Genesets)
significance_threshold.input <- unique(Full_data$Significance_thresholds)
DSM.input <- unique(Full_data$samples.i.)

whole_genome_genic_positions_Full_data <- grep(x = Full_data$Gene_regions, pattern = "genic.genome_SCORE_whole_genome",perl = T)
whole_genome_all_genome_positions_Full_data <- grep(x = Full_data$Gene_regions, pattern = "All.genome_SCORE_whole_genome",perl = T)


Full_data[whole_genome_genic_positions_Full_data, Gene_regions := gsub(pattern = "^(.*).genic.genome_SCORE_.*", replacement = "\\1", x = Full_data$Gene_regions[whole_genome_genic_positions_Full_data],perl = T)]

Full_data[whole_genome_all_genome_positions_Full_data, Gene_regions := gsub(pattern = ".*", replacement = "NA", x = Full_data$Gene_regions[whole_genome_all_genome_positions_Full_data],perl = T)]

extra_table <- Full_data[whole_genome_all_genome_positions_Full_data]
cols <- c("estimate", "SE","r.squared","p")
  
inputPanel(
  checkboxGroupInput("Significance_threshold", label = "PRS P Value Threshold:",
              choices = significance_threshold.input, selected = "0.05"),
  checkboxGroupInput("Gene_regions", label = "Length of Gene regions:",
              choices = c("extended","normal")),
  selectInput("DSM", label = "DSM type:",
              choices = DSM.input),
  checkboxGroupInput("geneset", label = "Geneset PRS to include:",
                     choices = Gene.sets.input)
)

renderDataTable({
  if (is.null(input$Significance_threshold)) {
        return(NULL)
  }    
  if (is.null(input$geneset)) {
        return(NULL)
  }    
  if (is.null(input$Gene_regions)) {
        return(NULL)
  }    

  sample_analysis_extra <- extra_table %>%
    filter(samples.i. == input$DSM,
           Significance_thresholds %in% input$Significance_threshold,
           Genesets %in% input$geneset
           )
  
  sample_analysis <- Full_data %>%
    filter(samples.i. == input$DSM,
           Gene_regions %in% input$Gene_regions,
           Significance_thresholds %in% input$Significance_threshold,
           Genesets %in% input$geneset
           ) 
    Sample_analysis_2 <- rbindlist(list(sample_analysis,sample_analysis_extra)) %>%
    select(c(score:SE,p,r.squared)) %>%
    arrange(p)
    
    Sample_analysis_2 <- as.data.table(Sample_analysis_2)
    
    Sample_analysis_2[, (cols) := lapply(.SD, formatC, digits = 3, format = "g"), .SDcols = cols]
    
 datatable(data = Sample_analysis_2,
            options = list(pageLength = 10),
            rownames = F)
})
```

```{r echo = F, eval=FALSE, message=FALSE, include=FALSE, results=F}
#current_table_extended <- current_table_extended[order(current_table$p)]
#current_table_normal <- current_table_normal[order(current_table_normal$p)]
#current_table_extended_All.genome <- current_table_extended_All.genome[order(current_table_extended_All.genome$p)]
#current_table_normal_All.genome <- current_table_normal_All.genome[order(current_table_normal_All.genome$p)]



#Full_analysis_list <- list( analysis1, analysis2, analysis3, analysis4)
#cut_down_analysis_list <- Full_analysis_list

Analysis_vector <- c("normal vs whole genome genic", "extended vs whole genome genic", "normal vs whole genome all", "extended vs whole genome all")

samples2 <- c("Everything", "broad", "narrow", "All_minus_narrow")

for (t in 3:4){
  
current_analysis <- Final_analysis[[t]]

 if (t > 2){
   to_remove <- current_analysis[,.I[grepl("genic.genome",current_analysis$score)]]
   current_analysis <- current_analysis[-to_remove]
 } 
setkey(current_analysis, "samples.i.")
cutdown_tables_current <- current_analysis[order(p)]
cutdown_tables_current <- cutdown_tables_current[,.SD[1:10], by = samples.i.]

cutdown_tables_current %>% 
mutate_if(is.factor, as.character) -> cutdown_tables_current

print(
kable(cutdown_tables_current[,c(1,2,4:ncol(cutdown_tables_current))], format = "html",caption = paste0("Cognition;",Analysis_vector[t],";across different DSM ranges")) %>%
kable_styling("striped", full_width = F, position = "left",bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>%
group_rows(cutdown_tables_current[1,"samples.i."], 1, 10) %>%
group_rows(cutdown_tables_current[11,"samples.i."], 11, 20) %>%
group_rows(cutdown_tables_current[21,"samples.i."], 21, 30) %>%
group_rows(cutdown_tables_current[31,"samples.i."], 31, 40 ) %>%  
add_footnote(c("Some footnote", "Some other footnote"))
)
}

for (t in 1:3){
kable(all_TRS_PRS_results[[t]][1:20,], caption = "TRS tables across different DSM ranges")
}
```

### Plotting
```{r echo = F,message = F, results=F, warning=F}

Final_analysis_gglist_pval <- list()
Final_analysis_beta <- list()
Final_analysis_r2_pathways <- list()

gglist_pathways <- list()
gglist_beta_pathways <- list()
gglist_r2_dir_pathways <- list()

for (t in 1:4){

current_table <- Final_analysis[[t]]

# Pathways
str(current_table)

COGS_only_0.5 <- current_table[grepl("_0.5",current_table$score)] 
COGS_only_0.05 <- current_table[grepl("_0.05",current_table$score)] 

#COGS_only_0.05 <- COGS_only_0.05[!grepl("abnormal_grooming_behavior", COGS_only_0.05$score)]
#COGS_only_0.5 <- COGS_only_0.5[!grepl("abnormal_grooming_behavior", COGS_only_0.5$score)]

#COGS_only_0.05 <- COGS_only_0.05[!grepl("Lek2015_LoFintolerant_90", COGS_only_0.05$score)]
#COGS_only_0.5 <- COGS_only_0.5[!grepl("Lek2015_LoFintolerant_90", COGS_only_0.5$score)]

split_data_frame_0.05 <- split(COGS_only_0.05, by = "test")
split_data_frame_0.5 <- split(COGS_only_0.5, by = "test")

#setkey(split_data_frame_0.05,p)
#setkey(split_data_frame_0.5,p)

#Whole brain
#ALSPAC_all_brain_0.05 <- ALSPAC_full_brain_regions[grepl("_0.05",ALSPAC_full_brain_regions$score)]
#ALSPAC_all_brain_0.5 <- ALSPAC_full_brain_regions[grepl("_0.5",ALSPAC_full_brain_regions$score)] 



for (i in 1:length(split_data_frame_0.05)){
  
  
  # Obtaining the log p-values
  top_five_pathways <- split_data_frame_0.05[[i]][order(split_data_frame_0.05[[i]]$score)]
  top_five_pathways$P_threshold <- 0.05
  
  # Alter to find the whole genome row from the pathway rows
  top_five_pathways_0.05 <- top_five_pathways[,.I[grepl("genic.genome",top_five_pathways$score) | grepl("All.genome", top_five_pathways$score)]]
  Type_vector <- rep("Pathway",nrow(top_five_pathways))
  Type_vector[top_five_pathways_0.05] <- "Whole_genome"
  top_five_pathways$Type <- Type_vector
  
  # By Factoring the p-values, you can get them to trend decreasingly without affecting the whole genome p-value
  top_five_pathways$p <- as.numeric(top_five_pathways$p)
  top_five_pathways$score <- factor(top_five_pathways$score, levels = top_five_pathways$score[order(top_five_pathways$score, top_five_pathways$Type)])
  
  
  # Do the same for the 0.5 p-thresholds
  top_five_pathways2 <- split_data_frame_0.5[[i]][order(split_data_frame_0.5[[i]]$score)]
  top_five_pathways2$P_threshold <- 0.5
  
  top_five_pathways_0.5 <- top_five_pathways2[,.I[grepl("genic.genome",top_five_pathways2$score) | grepl("All.genome", top_five_pathways2$score)]]
  Type_vector <- rep("Pathway",nrow(top_five_pathways2))
  Type_vector[top_five_pathways_0.5] <- "Whole_genome"
  top_five_pathways2$Type <- Type_vector
  
  
  # By Factoring the p-values, you can get them to trend decreasingly without affecting the whole genome p-value
  top_five_pathways2$p <- as.numeric(top_five_pathways2$p)
  top_five_pathways2$score <- factor(top_five_pathways2$score, levels = top_five_pathways2$score[order(top_five_pathways2$score, top_five_pathways2$Type)])
  
  
  top_five_pathways_all <- rbind(top_five_pathways,top_five_pathways2)
  top_five_pathways_all$p <- as.numeric(top_five_pathways_all$p)
  top_five_pathways_all$logp <- -log10(top_five_pathways_all$p)
  
  top_five_pathways_all$estimate <- as.numeric(top_five_pathways_all$estimate)
  top_five_pathways_all$upper <- as.numeric(top_five_pathways_all$upper)
  top_five_pathways_all$lower <- as.numeric(top_five_pathways_all$lower)
  top_five_pathways_all$SE <- as.numeric(top_five_pathways_all$SE)
  
  top_five_pathways_all$SE_higher <- top_five_pathways_all$estimate + top_five_pathways_all$SE
  top_five_pathways_all$SE_lower <- top_five_pathways_all$estimate - top_five_pathways_all$SE
  
  top_five_pathways_all$r2_dir <- 100 * (as.numeric(top_five_pathways_all$r.squared) *
                                           (sign(as.numeric(top_five_pathways_all$estimate))))
  
  top_five_pathways_all$p_value_text <- paste("p =", scientific(top_five_pathways_all$p, digits = 2), sep = " ")
  assign(paste0(top_five_pathways_all$test[1],"_top_five_pathways_all_thresholds"), top_five_pathways_all, envir = .GlobalEnv)
  
  p <- ggplot(top_five_pathways_all, aes(x=score, y=logp, fill = Type, group=P_threshold))
  
  p <- p +
    geom_point(aes(colour = Type))
  
  test1 <- levels(p$data$score)
  whole_genome_positions <- grep(x = test1, pattern = "SCORE_whole_genome_\\d.\\d+",perl = T)
  
  if (t > 2){
    whole_genome_genic_positions <- grep(x = test1, pattern = "genic.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
    whole_genome_all_genome_positions <- grep(x = test1, pattern = "All.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
  }
  
  alterations <- test1
  alterations[-whole_genome_positions] <- str_replace(string = test1[-whole_genome_positions], pattern = "SCORE_(.*)_\\d.\\d+",replacement = "\\1")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "long_term_potentiation",replacement = "LTP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "action_potential",replacement = "AP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "depolarization",replacement = "DP")
  alterations[whole_genome_positions] <- rep(x = "Whole Genome PRS", 2)
  
  if (t > 2){
   alterations[whole_genome_genic_positions] <- rep(x = "Whole Genome PRS GENIC", 2)
   alterations[whole_genome_all_genome_positions] <- rep(x = "Whole Genome PRS ALL", 2)
  }
  
  test2 <- vector(length = length(test1))
  names(alterations) <- test1
  
  p <- p + scale_x_discrete(labels= alterations)
  #p <- p + scale_y
  p <- p + facet_grid(. ~ P_threshold,scales = "free_x", space = "free_x") +
    theme(strip.text.x = element_text(size = 10))
  p <- p + geom_hline(aes(yintercept=1.30103), colour = "red", linetype= "solid", alpha = 0.25)
  p <- p + scale_fill_brewer(palette = "Paired")
  p <- p + theme(axis.text.x = element_text(angle = 90,size = 10,hjust = 1,vjust = 0.5))
  p <- p + ggtitle(top_five_pathways_all$.id[1])
  #p <- p + theme(plot.title = element_text( face = "bold",hjust = 0.5,vjust = 0.5,angle = 90))
  p <- p + theme(plot.title = element_text( face = "bold",hjust = 0.5))
  p <- p + ylab(label = expression(-'log'[10]*'(p)'))
  p <- p + xlab(label = "Polygenic risk score")

  gglist_pathways[[i]] <- p
  
  p <- ggplot(top_five_pathways_all, aes(x=score, y=estimate, fill = Type, group=P_threshold))
  
  p <- p +
    geom_errorbar(aes(ymin = upper, ymax = lower), position = "dodge", width = 0.25) +
    geom_point(aes(colour = Type))
  
  test1 <- levels(p$data$score)
  whole_genome_positions <- grep(x = test1,pattern = "SCORE_whole_genome_\\d.\\d+",perl = T)
  
  if (t > 2){
    whole_genome_genic_positions <- grep(x = test1, pattern = "genic.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
    whole_genome_all_genome_positions <- grep(x = test1, pattern = "All.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
  }


  alterations <- test1
  alterations[-whole_genome_positions] <- str_replace(string = test1[-whole_genome_positions], pattern = "SCORE_(.*)_\\d.\\d+",replacement = "\\1")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "long_term_potentiation",replacement = "LTP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "action_potential",replacement = "AP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "depolarization",replacement = "DP")
  alterations[whole_genome_positions] <- rep(x = "Whole Genome PRS", 2)
  
  if (t > 2){
   alterations[whole_genome_genic_positions] <- rep(x = "Whole Genome PRS GENIC", 2)
   alterations[whole_genome_all_genome_positions] <- rep(x = "Whole Genome PRS ALL", 2)
  }
  
  test2 <- vector(length = length(test1))
  names(alterations) <- test1
  
  p <- p + scale_x_discrete(labels= alterations)
  p <- p + facet_grid(. ~ P_threshold, scales = "free_x", space = "free_x") +
    theme(strip.text.x = element_text(size = 10))
  p <- p + geom_hline(aes(yintercept=0), colour = "red", linetype= "solid", alpha = 0.25)
  p <- p + scale_fill_brewer(palette = "Paired")
  p <- p + theme(axis.text.x = element_text(angle = 90,size = 10,hjust = 1,vjust = 0.5))
  p <- p + ggtitle(top_five_pathways_all$.id[1])
  p <- p + theme(plot.title = element_text( face = "bold",hjust = 0.5))
  p <- p + ylab(label = "BETA")
  p <- p + xlab(label = "Polygenic risk score")
  
  gglist_beta_pathways[[i]] <- p
  
  p <- ggplot(top_five_pathways_all, aes(x=score, y=r2_dir, fill = Type, group=P_threshold))
  p <- p +
    geom_bar(stat = "identity", aes(colour = Type), position = "dodge") +
    geom_text(data=subset(top_five_pathways_all, p < 0.05),
              aes(x=score,y=r2_dir,label=p_value_text, hjust=ifelse(sign(r2_dir)>0, 0, 0)), angle = 90, position = position_dodge(width = 1), size = 2.9)

 #Problem with labels with a workaround
  # I use the score column in the format of factors and reference each relevant dataset for ggplot.
  # However this relies on having 0.05 and 0.5 in the value name.
  # scale_x_discrete accepts functions, but I also need to convert SCORE_0.05 and Score_0.5 into a "Whole_genome_PRS" which is almost impossible to write"
  # However as the labels function accepts key:value pairs, I wrote a vector in R that maps the original names of the pathways to "human readable" format using names function in R
  # This should work for most instances
  
  test1 <- levels(p$data$score)
  whole_genome_positions <- grep(x = test1,pattern = "SCORE_whole_genome_\\d.\\d+",perl = T)
  alterations <- test1
  
  if (t > 2){
    whole_genome_genic_positions <- grep(x = test1, pattern = "genic.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
    whole_genome_all_genome_positions <- grep(x = test1, pattern = "All.genome_SCORE_whole_genome_\\d.\\d+",perl = T)
  }

  
  alterations[-whole_genome_positions] <- str_replace(string = test1[-whole_genome_positions], pattern = "SCORE_(.*)_\\d.\\d+",replacement = "\\1")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "long_term_potentiation",replacement = "LTP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "action_potential",replacement = "AP")
  alterations[-whole_genome_positions] <- str_replace(string = alterations[-whole_genome_positions], pattern = "depolarization",replacement = "DP")
  alterations[whole_genome_positions] <- rep(x = "Whole Genome PRS", 2)
  test2 <- vector(length = length(test1))
  names(alterations) <- test1
  
  if (t > 2){
   alterations[whole_genome_genic_positions] <- rep(x = "Whole Genome PRS GENIC", 2)
   alterations[whole_genome_all_genome_positions] <- rep(x = "Whole Genome PRS ALL", 2)
  }
  
  p <- p + scale_x_discrete(labels= alterations)

  p <- p + scale_y_continuous(expand = expand_scale(mult = c(0.2,.6)))
  p <- p + facet_grid(. ~ P_threshold, scales = "free_x", space = "free_x") +
    theme(strip.text.x = element_text(size = 10))
  p <- p + theme(axis.text.x = element_text(angle = 90, size = 10, hjust = 1,vjust = 0.5))
  p <- p + ggtitle(top_five_pathways_all$.id[1])
  p <- p + theme(plot.title = element_text( face = "bold",hjust = 0.5))
  p <- p + ylab(label = "R2_dir (%)")
  p <- p + xlab(label = "Polygenic risk score")
  
  gglist_r2_dir_pathways[[i]] <- p
  
  
}

Final_analysis_gglist_pval[[t]] <- gglist_pathways
Final_analysis_beta[[t]] <- gglist_beta_pathways
Final_analysis_r2_pathways[[t]] <- gglist_r2_dir_pathways

}





```
#### Save the plots to File

```{r, message=F, include=F}
pdf("~/Documents/COGS_pathways_results/COGS_CLOZUK_pathway_whole_genome_genic_comparison_R2_dir_12_pathways_EXTENDED_REGIONS.pdf", onefile = TRUE)
invisible(lapply(Final_analysis_r2_pathways[[3]],print))
dev.off()

pdf("~/Documents/COGS_pathways_results/COGS_CLOZUK_pathway_whole_genome_genic_comparison_R2_dir_12_pathways_NORMAL_REGIONS.pdf", onefile = TRUE)
invisible(lapply(Final_analysis_r2_pathways[[4]],print))
dev.off()


pdf("~/Documents/COGS_pathways_results/COGS_CLOZUK_pathway_whole_genome_genic_comparison_beta_12_pathways_EXTENDED_REGIONS.pdf", onefile = TRUE)
invisible(lapply(Final_analysis_beta[[3]],print))
dev.off()

pdf("~/Documents/COGS_pathways_results/COGS_CLOZUK_pathway_whole_genome_genic_comparison_beta_12_pathways_NORMAL_REGIONS.pdf", onefile = TRUE)
invisible(lapply(Final_analysis_beta[[4]],print))
dev.off()

# NOT RUN {
x <- knitr::kable(head(mtcars), "html")
# Add a row of header with 3 columns on the top of the table. The column
# span for the 2nd and 3rd one are 5 & 6.
add_header_above(x, c(" ", "Group 1" = 5, "Group 2" = 6))

```
 

This R Markdown document is made interactive using Shiny. Unlike the more traditional workflow of creating static reports, you can now create documents that allow your readers to change the assumptions underlying your analysis and see the results immediately. 

To learn more, see [Interactive Documents](http://rmarkdown.rstudio.com/authoring_shiny.html).

## Inputs and Outputs

You can embed Shiny inputs and outputs in your document. Outputs are automatically updated whenever inputs change.  This demonstrates how a standard R plot can be made interactive by wrapping it in the Shiny `renderPlot` function. The `selectInput` and `sliderInput` functions create the input widgets used to drive the plot.

```{r eruptions, echo=FALSE}
inputPanel(
  selectInput("n_breaks", label = "Number of bins:",
              choices = c(10, 20, 35, 50), selected = 20),
  
  sliderInput("bw_adjust", label = "Bandwidth adjustment:",
              min = 0.2, max = 2, value = 1, step = 0.2)
)

renderPlot({
  hist(faithful$eruptions, probability = TRUE, breaks = as.numeric(input$n_breaks),
       xlab = "Duration (minutes)", main = "Geyser eruption duration")
  
  dens <- density(faithful$eruptions, adjust = input$bw_adjust)
  lines(dens, col = "blue")
})
```

## Embedded Application

It's also possible to embed an entire Shiny application within an R Markdown document using the `shinyAppDir` function. This example embeds a Shiny application located in another directory:

```{r tabsets, echo=FALSE}
shinyAppDir(
  system.file("examples/06_tabsets", package = "shiny"),
  options = list(
    width = "100%", height = 550
  )
)
```

Note the use of the `height` parameter to determine how much vertical space the embedded application should occupy.

You can also use the `shinyApp` function to define an application inline rather then in an external directory.

In all of R code chunks above the `echo = FALSE` attribute is used. This is to prevent the R code within the chunk from rendering in the document alongside the Shiny components.



